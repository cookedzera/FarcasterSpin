// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

/**
 * @title WheelGameArbitrumSepolia
 * @notice A wheel-of-fortune style casino game for Farcaster Mini App on Arbitrum Sepolia
 * @dev Implements daily spin limits, accumulated rewards, and claim mechanism
 */
contract WheelGameArbitrumSepolia is ReentrancyGuard, Ownable {
    using SafeERC20 for IERC20;

    // Constants
    uint256 public constant DAILY_SPIN_LIMIT = 5;
    uint256 public constant SECONDS_IN_DAY = 86400;
    
    // Immutable token addresses
    IERC20 public immutable aidogeToken;
    IERC20 public immutable boopToken;
    IERC20 public immutable bobotrumToken;
    
    // Wheel segments
    string[8] private constant WHEEL_SEGMENTS = [
        "AIDOGE",
        "BUST",
        "BOOP",
        "BONUS",
        "BOBOTRUM",
        "BUST",
        "AIDOGE",
        "JACKPOT"
    ];
    
    // Base reward amounts (in wei)
    uint256 private constant AIDOGE_BASE_REWARD = 1 ether;
    uint256 private constant BOOP_BASE_REWARD = 2 ether;
    uint256 private constant BOBOTRUM_BASE_REWARD = 0.5 ether;
    
    // Multipliers
    uint256 private constant BONUS_MULTIPLIER = 2;
    uint256 private constant JACKPOT_MULTIPLIER = 10;
    
    // Player statistics structure
    struct PlayerStats {
        uint256 totalSpins;
        uint256 totalWins;
        uint256 lastSpinDate;
        uint256 dailySpins;
    }
    
    // Pending rewards structure
    struct PendingRewards {
        uint256 aidoge;
        uint256 boop;
        uint256 bobotrum;
    }
    
    // Mappings
    mapping(address => PlayerStats) public playerStats;
    mapping(address => PendingRewards) public pendingRewards;
    
    // Nonce for randomness
    uint256 private nonce;
    
    // Emergency pause
    bool public paused;
    
    // Events
    event SpinResult(
        address indexed player,
        string segment,
        bool isWin,
        address tokenAddress,
        uint256 rewardAmount,
        uint256 randomSeed
    );
    
    event RewardsClaimed(
        address indexed player,
        address indexed token,
        uint256 amount
    );
    
    event EmergencyPause(bool status);
    event TokensDeposited(address indexed token, uint256 amount);
    event EmergencyWithdraw(address indexed token, uint256 amount);
    
    // Custom errors
    error GamePaused();
    error DailyLimitReached();
    error NoPendingRewards();
    error InsufficientContractBalance();
    error InvalidTokenAddress();
    error TransferFailed();
    
    // Modifiers
    modifier whenNotPaused() {
        if (paused) revert GamePaused();
        _;
    }
    
    /**
     * @notice Constructor to initialize the game with token addresses
     * @param _aidogeToken Address of AIDOGE token on Arbitrum Sepolia
     * @param _boopToken Address of BOOP token on Arbitrum Sepolia
     * @param _bobotrumToken Address of BOBOTRUM token on Arbitrum Sepolia
     */
    constructor(
        address _aidogeToken,
        address _boopToken,
        address _bobotrumToken
    ) {
        aidogeToken = IERC20(_aidogeToken);
        boopToken = IERC20(_boopToken);
        bobotrumToken = IERC20(_bobotrumToken);
    }
    
    /**
     * @notice Main spin function for players to spin the wheel
     * @return segment The wheel segment landed on
     * @return isWin Whether the spin resulted in a win
     * @return tokenAddress Address of the token won (if any)
     * @return rewardAmount Amount of tokens won
     */
    function spin() 
        external 
        whenNotPaused 
        nonReentrant 
        returns (
            string memory segment,
            bool isWin,
            address tokenAddress,
            uint256 rewardAmount
        ) 
    {
        // Check and update daily limit
        _checkAndUpdateDailyLimit(msg.sender);
        
        // Generate random number
        uint256 randomSeed = _generateRandomNumber();
        uint256 segmentIndex = randomSeed % 8;
        segment = WHEEL_SEGMENTS[segmentIndex];
        
        // Update player stats
        playerStats[msg.sender].totalSpins++;
        
        // Process spin result
        if (keccak256(bytes(segment)) == keccak256(bytes("AIDOGE"))) {
            isWin = true;
            tokenAddress = address(aidogeToken);
            rewardAmount = AIDOGE_BASE_REWARD;
            pendingRewards[msg.sender].aidoge += rewardAmount;
        } else if (keccak256(bytes(segment)) == keccak256(bytes("BOOP"))) {
            isWin = true;
            tokenAddress = address(boopToken);
            rewardAmount = BOOP_BASE_REWARD;
            pendingRewards[msg.sender].boop += rewardAmount;
        } else if (keccak256(bytes(segment)) == keccak256(bytes("BOBOTRUM"))) {
            isWin = true;
            tokenAddress = address(bobotrumToken);
            rewardAmount = BOBOTRUM_BASE_REWARD;
            pendingRewards[msg.sender].bobotrum += rewardAmount;
        } else if (keccak256(bytes(segment)) == keccak256(bytes("BONUS"))) {
            // Random token with 2x multiplier
            uint256 tokenChoice = randomSeed % 3;
            isWin = true;
            if (tokenChoice == 0) {
                tokenAddress = address(aidogeToken);
                rewardAmount = AIDOGE_BASE_REWARD * BONUS_MULTIPLIER;
                pendingRewards[msg.sender].aidoge += rewardAmount;
            } else if (tokenChoice == 1) {
                tokenAddress = address(boopToken);
                rewardAmount = BOOP_BASE_REWARD * BONUS_MULTIPLIER;
                pendingRewards[msg.sender].boop += rewardAmount;
            } else {
                tokenAddress = address(bobotrumToken);
                rewardAmount = BOBOTRUM_BASE_REWARD * BONUS_MULTIPLIER;
                pendingRewards[msg.sender].bobotrum += rewardAmount;
            }
        } else if (keccak256(bytes(segment)) == keccak256(bytes("JACKPOT"))) {
            // Random token with 10x multiplier
            uint256 tokenChoice = randomSeed % 3;
            isWin = true;
            if (tokenChoice == 0) {
                tokenAddress = address(aidogeToken);
                rewardAmount = AIDOGE_BASE_REWARD * JACKPOT_MULTIPLIER;
                pendingRewards[msg.sender].aidoge += rewardAmount;
            } else if (tokenChoice == 1) {
                tokenAddress = address(boopToken);
                rewardAmount = BOOP_BASE_REWARD * JACKPOT_MULTIPLIER;
                pendingRewards[msg.sender].boop += rewardAmount;
            } else {
                tokenAddress = address(bobotrumToken);
                rewardAmount = BOBOTRUM_BASE_REWARD * JACKPOT_MULTIPLIER;
                pendingRewards[msg.sender].bobotrum += rewardAmount;
            }
        } else {
            // BUST - no reward
            isWin = false;
            tokenAddress = address(0);
            rewardAmount = 0;
        }
        
        // Update win counter
        if (isWin) {
            playerStats[msg.sender].totalWins++;
        }
        
        // Emit event
        emit SpinResult(msg.sender, segment, isWin, tokenAddress, rewardAmount, randomSeed);
        
        return (segment, isWin, tokenAddress, rewardAmount);
    }
    
    /**
     * @notice Claim accumulated rewards for a specific token
     * @param tokenAddress Address of the token to claim
     */
    function claimRewards(address tokenAddress) external whenNotPaused nonReentrant {
        uint256 amount;
        IERC20 token;
        
        if (tokenAddress == address(aidogeToken)) {
            amount = pendingRewards[msg.sender].aidoge;
            if (amount == 0) revert NoPendingRewards();
            pendingRewards[msg.sender].aidoge = 0;
            token = aidogeToken;
        } else if (tokenAddress == address(boopToken)) {
            amount = pendingRewards[msg.sender].boop;
            if (amount == 0) revert NoPendingRewards();
            pendingRewards[msg.sender].boop = 0;
            token = boopToken;
        } else if (tokenAddress == address(bobotrumToken)) {
            amount = pendingRewards[msg.sender].bobotrum;
            if (amount == 0) revert NoPendingRewards();
            pendingRewards[msg.sender].bobotrum = 0;
            token = bobotrumToken;
        } else {
            revert InvalidTokenAddress();
        }
        
        // Check contract balance
        if (token.balanceOf(address(this)) < amount) {
            revert InsufficientContractBalance();
        }
        
        // Transfer tokens
        token.safeTransfer(msg.sender, amount);
        
        emit RewardsClaimed(msg.sender, tokenAddress, amount);
    }
    
    /**
     * @notice Claim all accumulated rewards at once
     */
    function claimAllRewards() external whenNotPaused nonReentrant {
        PendingRewards memory rewards = pendingRewards[msg.sender];
        
        if (rewards.aidoge == 0 && rewards.boop == 0 && rewards.bobotrum == 0) {
            revert NoPendingRewards();
        }
        
        // Clear pending rewards first (reentrancy protection)
        pendingRewards[msg.sender] = PendingRewards(0, 0, 0);
        
        // Transfer AIDOGE
        if (rewards.aidoge > 0) {
            if (aidogeToken.balanceOf(address(this)) < rewards.aidoge) {
                revert InsufficientContractBalance();
            }
            aidogeToken.safeTransfer(msg.sender, rewards.aidoge);
            emit RewardsClaimed(msg.sender, address(aidogeToken), rewards.aidoge);
        }
        
        // Transfer BOOP
        if (rewards.boop > 0) {
            if (boopToken.balanceOf(address(this)) < rewards.boop) {
                revert InsufficientContractBalance();
            }
            boopToken.safeTransfer(msg.sender, rewards.boop);
            emit RewardsClaimed(msg.sender, address(boopToken), rewards.boop);
        }
        
        // Transfer BOBOTRUM
        if (rewards.bobotrum > 0) {
            if (bobotrumToken.balanceOf(address(this)) < rewards.bobotrum) {
                revert InsufficientContractBalance();
            }
            bobotrumToken.safeTransfer(msg.sender, rewards.bobotrum);
            emit RewardsClaimed(msg.sender, address(bobotrumToken), rewards.bobotrum);
        }
    }
    
    /**
     * @notice Get player statistics
     * @param player Address of the player
     * @return totalSpins Total number of spins
     * @return totalWins Total number of wins
     * @return lastSpinDate Last spin date (day number)
     * @return dailySpins Spins used today
     * @return spinsRemaining Spins remaining today
     */
    function getPlayerStats(address player) 
        external 
        view 
        returns (
            uint256 totalSpins,
            uint256 totalWins,
            uint256 lastSpinDate,
            uint256 dailySpins,
            uint256 spinsRemaining
        ) 
    {
        PlayerStats memory stats = playerStats[player];
        uint256 currentDay = block.timestamp / SECONDS_IN_DAY;
        
        if (stats.lastSpinDate < currentDay) {
            // New day, all spins available
            return (stats.totalSpins, stats.totalWins, stats.lastSpinDate, 0, DAILY_SPIN_LIMIT);
        } else {
            // Same day
            uint256 remaining = DAILY_SPIN_LIMIT > stats.dailySpins ? 
                DAILY_SPIN_LIMIT - stats.dailySpins : 0;
            return (stats.totalSpins, stats.totalWins, stats.lastSpinDate, stats.dailySpins, remaining);
        }
    }
    
    /**
     * @notice Get pending rewards for a player
     * @param player Address of the player
     * @return aidoge Pending AIDOGE tokens
     * @return boop Pending BOOP tokens
     * @return bobotrum Pending BOBOTRUM tokens
     */
    function getPendingRewards(address player) 
        external 
        view 
        returns (
            uint256 aidoge,
            uint256 boop,
            uint256 bobotrum
        ) 
    {
        PendingRewards memory rewards = pendingRewards[player];
        return (rewards.aidoge, rewards.boop, rewards.bobotrum);
    }
    
    /**
     * @notice Get wheel segments
     * @return Array of wheel segments
     */
    function getWheelSegments() external pure returns (string[] memory) {
        string[] memory segments = new string[](8);
        for (uint256 i = 0; i < 8; i++) {
            segments[i] = WHEEL_SEGMENTS[i];
        }
        return segments;
    }
    
    /**
     * @notice Check and update daily spin limit
     * @param player Address of the player
     */
    function _checkAndUpdateDailyLimit(address player) private {
        uint256 currentDay = block.timestamp / SECONDS_IN_DAY;
        PlayerStats storage stats = playerStats[player];
        
        if (stats.lastSpinDate < currentDay) {
            // New day, reset daily spins
            stats.lastSpinDate = currentDay;
            stats.dailySpins = 1;
        } else {
            // Same day, check limit
            if (stats.dailySpins >= DAILY_SPIN_LIMIT) {
                revert DailyLimitReached();
            }
            stats.dailySpins++;
        }
    }
    
    /**
     * @notice Generate pseudo-random number
     * @return Random number
     */
    function _generateRandomNumber() private returns (uint256) {
        nonce++;
        return uint256(
            keccak256(
                abi.encodePacked(
                    block.timestamp,
                    block.prevrandao,
                    msg.sender,
                    nonce
                )
            )
        );
    }
    
    // Owner functions
    
    /**
     * @notice Pause/unpause the game
     * @param _paused Pause status
     */
    function setPaused(bool _paused) external onlyOwner {
        paused = _paused;
        emit EmergencyPause(_paused);
    }
    
    /**
     * @notice Deposit tokens to the contract
     * @param tokenAddress Address of the token
     * @param amount Amount to deposit
     */
    function depositTokens(address tokenAddress, uint256 amount) external onlyOwner {
        if (tokenAddress != address(aidogeToken) && 
            tokenAddress != address(boopToken) && 
            tokenAddress != address(bobotrumToken)) {
            revert InvalidTokenAddress();
        }
        
        IERC20(tokenAddress).safeTransferFrom(msg.sender, address(this), amount);
        emit TokensDeposited(tokenAddress, amount);
    }
    
    /**
     * @notice Emergency withdraw tokens
     * @param tokenAddress Address of the token
     * @param amount Amount to withdraw
     */
    function emergencyWithdraw(address tokenAddress, uint256 amount) external onlyOwner {
        if (tokenAddress != address(aidogeToken) && 
            tokenAddress != address(boopToken) && 
            tokenAddress != address(bobotrumToken)) {
            revert InvalidTokenAddress();
        }
        
        IERC20(tokenAddress).safeTransfer(owner(), amount);
        emit EmergencyWithdraw(tokenAddress, amount);
    }
    
    /**
     * @notice Get contract balances
     * @return aidogeBalance AIDOGE balance
     * @return boopBalance BOOP balance
     * @return bobotrumBalance BOBOTRUM balance
     */
    function getContractBalances() 
        external 
        view 
        returns (
            uint256 aidogeBalance,
            uint256 boopBalance,
            uint256 bobotrumBalance
        ) 
    {
        return (
            aidogeToken.balanceOf(address(this)),
            boopToken.balanceOf(address(this)),
            bobotrumToken.balanceOf(address(this))
        );
    }
}